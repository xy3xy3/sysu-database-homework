姓名：胡瑞康

学号：22336087


# 第1题：可变长度记录表示中的Null Bitmap

## 1.a. 对于变长字段，如果值为空，偏移（offset）和长度（length）字段将存储什么？

在可变长度记录表示中，**Null Bitmap** 用于指示各个属性是否为NULL。当某个变长字段的值为空时：

- **偏移（offset）字段**：通常会存储一个特殊值，比如 `0` 或 `-1`，表示该字段没有有效的数据位置。
- **长度（length）字段**：会存储 `0`，表示该字段的长度为零，即没有数据。

这种表示方式可以有效地标识出该字段为空，同时避免了不必要的数据存储。

## 1.b. 如果元组具有大量属性，其中大多数属性为空，是否可以修改记录表示，使得Null属性的唯一开销是Null Bitmap中的一个bit？

是的，可以通过以下方式优化记录表示：

- **使用Null Bitmap**：为每个属性分配一个比特位，用于指示该属性是否为NULL。这样，即使有大量属性为空，只有对应的比特位被设置，节省了空间。

- **可变长度字段的优化**：对于变长字段，如果其值为空，不存储实际的偏移和长度信息，只通过Null Bitmap标识为空。这避免了为每个NULL属性分配额外的偏移和长度字段的空间。

这种方法的优点在于：

- **空间效率高**：对于大量为空的属性，只需使用一个比特位，而无需额外的空间来存储偏移和长度。
- **简化处理**：在数据访问和更新时，可以快速检查Null Bitmap，确定哪些属性为空，减少不必要的操作。

# 2. 构建一棵 $B +$ 树,其中包含以下一组键值:

(2,3,5,7,11,17,19,23,29,31)

假设该树最初为空,并且值按升序添加。构建 B+树,其中树的节点可以容纳的指针数量分别如下:

## 2.a. 四个
```
Level 0: [19]
Level 1: [5, 11] | [29]
Level 2: [2, 3] | [5, 7] | [11, 17] | [19, 23] | [29, 31]
```
## 2.b. 六个
```
Level 0: [7, 19]
Level 1: [2, 3, 5] | [7, 11, 17] | [19, 23, 29, 31]
```

## 2.c. 八个
```
Level 0: [11]
Level 1: [2, 3, 5, 7] | [11, 17, 19, 23, 29, 31]
```

# 第3题：查询步骤说明

针对练习2中构建的每一棵B⁺树，以下分别说明查找键值为11的记录以及查找键值在7到17之间（包括7和17）的记录所涉及的步骤。

## 3.a. 查找搜索键值为11的记录

## **2.a. 每个节点可容纳4个指针的B⁺树**

1. **从根节点开始**：[19]
2. **比较11与19**：11 < 19，转向第一个子节点。
3. **访问第一个子节点**：[5, 11]
4. **在此节点中查找11**：找到11所在的位置。
5. **定位到叶子节点**：[11,17]，返回对应的记录。

## **2.b. 每个节点可容纳6个指针的B⁺树**

1. **从根节点开始**：[7, 19]
2. **比较11与7、19**：7 < 11 < 19，转向第二个子节点。
3. **访问第二个子节点**：[7,11,17]
4. **在此节点中查找11**：找到11所在的位置。
5. **定位到叶子节点**：[11,17]，返回对应的记录。

## **2.c. 每个节点可容纳8个指针的B⁺树**

1. **从根节点开始**：[11]
2. **比较11与11**：找到匹配，转向对应的子节点。
3. **访问对应的子节点**：[11,17,19,23,29,31]
4. **在此节点中查找11**：找到11所在的位置。
5. **定位到叶子节点**：[11,17]，返回对应的记录。

## 3.b. 查找搜索键值在7到17之间（包括7和17）的记录

## **2.a. 每个节点可容纳4个指针的B⁺树**

1. **从根节点开始**：[19]
2. **比较7与19**：7 < 19，转向第一个子节点。
3. **访问第一个子节点**：[5, 11]
4. **确定范围**：7 ≤ 11
5. **遍历相关叶子节点**：
   - [5,7]：包含7
   - [11,17]：包含11和17
6. **返回这两个叶子节点中的记录**。

## **2.b. 每个节点可容纳6个指针的B⁺树**

1. **从根节点开始**：[7, 19]
2. **比较7和19**：7 ≤ 7 ≤ 19，转向第一个子节点。
3. **访问第一个子节点**：[2,3,5]
   - 由于7不在此范围，继续查找。
4. **转向第二个子节点**：[7,11,17]
5. **遍历相关叶子节点**：
   - [7,11,17]：包含7、11、17
6. **返回该叶子节点中的记录**。

## **2.c. 每个节点可容纳8个指针的B⁺树**

1. **从根节点开始**：[11]
2. **比较7与11**：7 < 11，转向第一个子节点。
3. **访问第一个子节点**：[2,3,5,7]
4. **比较17与11**：17 > 11，转向第二个子节点。
5. **访问第二个子节点**：[11,17,19,23,29,31]
6. **遍历相关叶子节点**：
   - [2,3,5,7]：包含7
   - [11,17,19,23,29,31]：包含11和17
7. **返回这两个叶子节点中的记录**。

# 第4题：按排序顺序插入索引条目时B⁺树叶子节点的占用情况

当按照键值的升序顺序插入索引条目时，B⁺树的叶子节点会呈现特定的占用模式。具体表现如下：

1. **叶子节点的填充方式**：
   - 由于插入是按排序顺序进行，新的键值总是插入到当前最右边的叶子节点。
   - 这导致叶子节点从左到右依次被填满，直到达到其容量限制。

2. **节点分裂的模式**：
   - 当一个叶子节点达到其最大容量时，会进行分裂，将中间的键值提升到父节点。
   - 由于插入顺序是有序的，分裂通常发生在叶子节点的最右边。

3. **占用情况的特点**：
   - **初始阶段**：叶子节点会逐渐被填满，直到需要分裂。
   - **后期阶段**：叶子节点几乎总是被完全填满，接近或达到其最大容量。
   - **整体效果**：叶子节点的占用率较高，空间利用率良好，减少了空间的浪费。

4. **原因分析**：
   - 顺序插入导致数据集中在特定的叶子节点，减少了节点间的数据分布均衡性。
   - 分裂操作频繁发生在叶子节点的末端，确保每个叶子节点都被充分利用。

综上所述，按排序顺序插入索引条目会使B⁺树的叶子节点逐步被填满，保持较高的空间利用率，同时在达到节点容量限制时进行适当的分裂操作，以维持树的平衡性和查询效率。